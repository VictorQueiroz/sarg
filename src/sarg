#!/usr/bin/env node
const glob = require('glob');
const path = require('path');
const difflet = require('difflet');

const chalk = require('chalk');
const fs = require('fs');
const gaze = require('gaze');
const diff = difflet({
    indent: 2,
    comment: true
});

async function run({ files, bail, keepCache }){
    console.log();

    let passed = 0,
        failed = 0;

    testsLoop:
    for(let i = 0; i < files.length; i++){
        let tests;

        console.log(files[i].replace(process.cwd() + '/', '') + ':');

        try {
            tests = require(files[i]);

            if(tests.__esModule)
                tests = tests.default;
        } catch(reason){
            console.error(reason);
            return false;
        }


        if(typeof tests === 'function'){
            tests = Object.assign({}, tests());
        }

        for(let name of Object.keys(tests)){
            console.log('%s ->', name);

            let start = Date.now();

            try {
                await tests[name]();
                console.log('%s (%sms)', chalk.green('ok'), Date.now() - start);
                if(i <= files.length - 1)
                    console.log();

                passed++;
            } catch(reason){
                failed++;
                console.log('%s (%sms)', chalk.red('failed'), Date.now() - start);

                if(reason.code === 'ERR_ASSERTION'){
                    process.stdout.write(diff.compare(reason.actual, reason.expected));
                } else {
                    console.error(reason);
                }

                console.log();
                if(bail){
                    clearCache(keepCache);
                    break testsLoop;
                }
            }
        }

        // invalidate require cache
        clearCache(keepCache);
    }

    console.log('---');
    console.log('%s passed, %s failed', chalk.green(passed), chalk.red(failed));
}

function clearCache(keepCache){
    for(let key of Object.keys(require.cache)){
        if(keepCache.indexOf(key) === -1 && !/node_modules/.test(key) && !/\.node$/.test(key))
            delete require.cache[key];
    }
}

function readArgs(args, options){
    if(args.length == 0)
        args = ['--help'];

    for(let i = 0; i < args.length; i++){
        // support --arg="x", --arg=x and --arg='x'
        if(args[i][0] === '-' && args[i].indexOf('=') > -1){
            const slices = args[i].split('=');

            if(slices[1] === '"' || slices[1] === "'")
                slices[1] = slices[1].substring(1, slices[1].length - 1);

            args.splice(i, 1, ...slices);
            i--;
            continue;
        }

        switch(args[i]){
            case '-b':
            case '--bail':
                options.bail = true;
                break;
            case '--license':
                fs.createReadStream(__dirname + '/../LICENSE').once('end', () => (
                    process.stdout.write('\n')
                )).pipe(process.stdout);
                return true;
            case '-v':
            case '--version':
                process.stdout.write(require('../package.json').name + ' ' + require('../package.json').version + '\n');
                return true;
            case '--require':
                require(args[++i]);
                break;
            case '-w':
            case '--watch':
                options.watch = options.watch.concat(args[++i].split(','));
                break;
            case '--ignore':
                options.ignore = options.ignore.concat(
                    glob.sync(path.resolve(process.cwd(), args[++i]))
                );
                break;
            case '-r':
            case '--recursive':
                options.pattern = path.resolve(process.cwd(), args[++i] + '/**/*{' + Object.keys(require.extensions).join(',') + '}');
                break;
            case '-h':
            case '--help':
                process.stdout.write('Usage:\n');
                process.stdout.write('  sarg [OPTION] [FILE]\n');
                process.stdout.write('\n');
                process.stdout.write('Help options:\n');
                process.stdout.write('  -h, --help                     Show help options\n');
                process.stdout.write('\n');
                process.stdout.write('Application options:\n');
                process.stdout.write('  --license                      Show license information and exit\n');
                process.stdout.write('  -v, --version                  Show version information and exit\n');
                process.stdout.write('  -b, --bail                     Stop tests when one of them fail\n');
                process.stdout.write('  -w, --watch=<directories>      List of directories to watch. Each directory needs to be separated by comma (i.e. --watch=src,test)\n');
                process.stdout.write('  --ignore=<pattern>             Ignore test files using the input pattern\n');
                process.stdout.write('  -r, --recursive=<directory>    Execute all JS files recursively inside directory\n');
                process.stdout.write('  --require=<path>               Execute NodeJS module before tests. Useful for executing ' +
                                                            'transpiler registers like `ts-node/register` or `babel-register`\n');
                return true;
            default:
                if(args[i][0] == '-' || args[i].substring(0, 2) == '--') {
                    process.stderr.write(`unrecognized option ${args[i]}\n`);
                    process.exit(1);
                    return true;
                }
                options.pattern = path.resolve(process.cwd(), args[i]);
        }
    }
    return false;
}

async function bootstrap(){
    const args = [].concat(process.argv);
    const options = {
        files: [],
        pattern: '',
        watch: [],
        ignore: [],
        bail: false,
        keepCache: []
    };

    if(readArgs(args.slice(2), options))
        return false;

    options.files = getFiles();

    function getFiles() {
        return glob.sync(options.pattern).map(file => (
            path.resolve(process.cwd(), file)
        ))
        .filter(path => {
            return options.ignore.indexOf(path) === -1;
        });
    }

    let _runTestsTimer;

    function runTests() {
        clearTimeout(_runTestsTimer);
        _runTestsTimer = setTimeout(() => {
            run({
                files: options.files,
                bail: options.bail,
                keepCache: options.keepCache
            });
        }, 100);
    }

    function updateFiles() {
        options.files = getFiles();
        runTests();
    }

    if(options.watch.length){
        const watcher = new gaze.Gaze(options.watch.map(dir => `${dir}/**/*.{${Object.keys(require.extensions).join(',')}}`));
        watcher.on('added', updateFiles);
        watcher.on('changed', runTests);
        watcher.on('deleted', updateFiles);
    }

    Object.keys(require.cache).forEach(key => {
        options.keepCache.push(key);
    });

    runTests();
}

bootstrap().catch(reason => {
    console.log(reason);
    process.exit(1);
});
